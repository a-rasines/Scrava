package domain.values;

import java.io.Serializable;
import java.util.Set;

import domain.Project;
import domain.Sprite;
import ui.renderers.SimpleBlockRenderer;

/**
 * Represents a static variable. This kind of variables get their value from user input
 * @param <T>
 */
public class StaticVariable<T> extends AbstractLiteral<T> implements IVariable<T> {
	
	/**
	 * A value pointer to create multiple instances of the same variable (for renderer purposes)
	 * @param <T>
	 */
	public static class Value<T> implements Serializable {
		private static final long serialVersionUID = -6209168702389374905L;
		
		private T value;
		public T initialValue;
		private Value(T value) {
			this.value = value;
			this.initialValue = value;
		}
		public Value(T value, T initialValue) {
			this.value = value;
			this.initialValue = initialValue;
		}
		
		
	}
	
	@Override
	public void reset() {
		this.value.value = this.value.initialValue;
	}

	private static final long serialVersionUID = 6146036704484981438L;
	
	/**
	 * Creates a global variable of the desired type with the desired initial value
	 * @param <T> Type of the variable
	 * @param name Unique name of the variable
	 * @param value Initial value of the variable
	 * @return
	 */
	public static <T> StaticVariable<T> createGlobalVariable(String name, T value) {
		return createVariable(null, name, value);
	}
	
	/**
	 * Create a local variable with the desired name and the default value
	 * @param <T> Type of the variable
	 * @param s Sprite where the variable is stored
	 * @param name name of the variable
	 * @param value initial value of the variable
	 * @return
	 */
	public static <T> StaticVariable<T> createVariable(Sprite s, String name, T value) {
		return createVariable(s, name, value, false);
	}
	/**
	 * Create a local variable with the desired name and the default value with the option of creating it native (not deletable)
	 * @param <T> Type of the variable
	 * @param s Sprite where the variable is stored
	 * @param name name of the variable
	 * @param value initial value of the variable
	 * @param whether it must be inmune to variable deleting
	 * @return
	 */
	public static <T> StaticVariable<T> createVariable(Sprite s, String name, T value, boolean nat) {
		StaticVariable<T> var = new StaticVariable<T>(name, value, s, nat);
		if(s != null)
			s.getProject().registerVariable(s, name, var);
		else
		Project.getActiveProject().registerVariable(s, name, var);
		return var;
	}
	
	@Override
	public AbstractLiteral<T> create(Sprite s) {
		return new StaticVariable<>(name, value, sprite, nat);
	}
	
	
	private String name;
	private boolean nat;
	public final Sprite sprite;
	private SimpleBlockRenderer sbr;
	private Value<T> value;
	
	private StaticVariable(String name, T value, Sprite sprite, boolean isNative) {
		super(value, null);
		this.name = name;
		this.value = new Value<>(value);
		this.sprite = sprite;
		this.nat = isNative;
		this.sbr = new SimpleBlockRenderer(this);
	}
	
	private StaticVariable(String name, Value<T> value, Sprite sprite, boolean isNative) {
		super(value.value, null);
		this.name = name;
		this.value = value;
		this.sprite = sprite;
		this.nat = isNative;
		this.sbr = new SimpleBlockRenderer(this);
	}
	
	@Override
	public SimpleBlockRenderer getRenderer() {
		return sbr;
	}
	
	/**
	 * Native variables are those that are generated by the sprite itself and therefore not deletable
	 * @return
	 */
	public boolean isNative() {
		return nat;
	}
	
	public boolean isGlobal() {
		return Project.getActiveProject().getVariable(null, this.name) != null;
	}
	
	public StaticVariable<?> setValue(T value) {
		this.value.value = value;
		return this;
	}
	
	public Class<?> getValueClass() {
		return value.getClass();
	}
	
	public String toString() {
		return (sprite==null?"GlobalVariables":sprite.getName()) +"."+name; 
	}
	
	@Override
	public T value() {
		return value.value;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public void setValue(Object object, boolean update) {
		this.value.value = (T)object;
		if(update)
			this.value.initialValue = (T)object;
		super.setValue(object, update);
	}
	
	@Override
	public T initialValue() {
		return value.initialValue;
	}
	@Override
	public String getCode() {
		return nat?"this.get" + this.name.substring(0, 1).toUpperCase() + this.name.substring(1) + "()" : this.name;
	}
	
	/**
	 * Gets the line representing the definition of the variable
	 * e.g: String varname = "defaultValue";
	 * @return
	 */
	public String getInitialization() {
		return NumberHelper.getEquivalent(this.initialValue().getClass()).getSimpleName() + " " + name + " = " + (this.initialValue() instanceof String? "\"" + this.initialValue() + "\"" : this.initialValue()) + ";";
	}
	
	@Override
	public void getImports(Set<String> imports) {}
	
	@Override
	public boolean isEmpty() {
		return false;
	}
	@SuppressWarnings("unchecked")
	@Override
	public void setValue(String str) {
		switch(initialValue()) {
			case String s:
				this.setValue((T)str, true);
				break;
			case Number n:
				this.setValue((T)NumberHelper.parse(str, n.getClass()), true);
				break;
			case Boolean b:
				this.setValue((T)(Boolean)Boolean.parseBoolean(str), true);
				break;
			default:
				
		}
			
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public void setName(String s) {
		this.name = s;
		
	}
	
	@Override
	public Sprite getSprite() {
		return sprite;
	}

}
